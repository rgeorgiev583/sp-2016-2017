# `exec(2)`

Това системно извикване се използва за стартиране на команда или изпълним файл вместо текущия процес (т.е. без да се създава нов процес).


## Синтаксис

       #include <unistd.h>

       int execl(const char* path, const char* arg, ..., NULL);
       int execlp(const char* cmd, const char* arg, ..., NULL);
       int execv(const char* path, char* const argv[]);
       int execvp(const char* cmd, char* const argv[]);


## Семантика

Всяка от дадените по-горе функции извършва едно и също нещо (замества изображението на текущия процес с подадената като аргумент команда), като просто приема различни аргументи:

* `execl` изпълнява файла с точен път `path`.  Пътят трябва да е абсолютен (например `/bin/sh`).  `execl` подава аргументите на функцията, започващи от втория, като командни аргументи (*command-line arguments*) на изпълнимия файл.  Списъкът с аргументи трябва задължително да завършва с нулев указател (*NULL*), който отбелязва неговия край и не се включва към самите командни аргументи.

* `execlp` изпълнява командата с име `cmd`.  Ако `cmd` започва със `/` (абсолютен път), функцията се държи като `execl`.  В противен случай тя търси изпълним файл с име `cmd` последователно във всички директории, посочени в променливата на средата `PATH`, докато не го намери.  Стойността на тази променлива изглежда по подобен начин (обикновено на различните системи записите са различни), като пътищата към директориите за обхождане се разделят със знака `:`:

		$ echo $PATH
		/usr/local/sbin:/usr/local/bin:/usr/bin

	При намирането на подходящ файл функцията го изпълнява по същия начин като `execl`.

* `execv` изпълнява файла с точен път `path` (аналогично на `execl`).  Тя подава аргументите на функцията, намиращи се в подадения като втори аргумент масив от низове, като командни аргументи (*command-line arguments*) на изпълнимия файл.  Последният елемент на масива трябва задължително да завършва с нулев указател (*NULL*), който отбелязва неговия край и не се включва към самите командни аргументи.

* `execvp` изпълнява командата с име `cmd` (аналогично на `execlp`).  Командните параметри се подават по същия начин, както при `execv`.

Не забравяйте, че по подразбиране първият команден аргумент винаги е името на командата или на изпълнимия файл.  (Това не е задължително да се спази, за да се изпълни успешно командата, но е добра практика.)

При успешно изпълнение нито една от горните функции не връща резултат.  При провал на която и да е от тях тя връща стойност `-1`.


## Задачи

(**Забележка**: `...` означава неограничен брой аргументи, а `[a|b|c]` означава "*или* `a`, *или* `b`, *или* `c`")

**(1., 2.)**  Изпълнете следната команда:

1. `cat FILE...`
	В случая `FILE...` са подадените на командния ред аргументи от втория натам.

2. `wc [-c|-w|-l] FILE...`
	Идеята е вторият команден аргумент да е един от низовете `-c`, `-w`, `-l`, а `FILE...` да са от третия натам.

3. Напишете програма `execute`, която изпълнява командния ред, подаден от втория команден аргумент натам.
	**Пример**: Извикването на `./execute cat foo bar baz` трябва да изпълни командата `cat foo bar baz`.

4. Напишете програма `count`, която изпълнява командата `wc` по различни начини в зависимост от подадените аргументи:

	* ако аргументите са `chars FILE...`, то да се изпълни `wc -c FILE...`;
	* ако аргументите са `words FILE...`, то да се изпълни `wc -w FILE...`;
	* ако аргументите са `lines FILE...`, то да се изпълни `wc -l FILE...`.

4. Напишете програма `trf`, която се извиква по следния начин:
	`trf SET1 SET2 FILE DEST`
	и изпълнява командата `tr SET1 SET2` по такъв начин, че тя да чете от файла `FILE` и да пише във файла `DEST`.

5. Напишете програма `wc2`, която изпълнява командата `wc [-c|-w|-l] FILE`, но без да извежда името на файла `FILE` (в случая само един), подаден като аргумент.
	**Подсказка**: Използвайте пренасочване на стандартния вход.
