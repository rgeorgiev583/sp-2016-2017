# `fork(2)`, `wait(2)`, `waitpid(2)`, `exit(2)`

Системното извикване `fork(2)` се използва за създаване на нов процес.
Системното извикване `wait(2)` се използва за изчакване да приключи произволен процес-дете.
Системното извикване `waitpid(2)` се използва за изчакване на конкретен процес-дете.
Библиотечната функция `exit(3)` се използва за приключване на изпълнението на процес.


# Синтаксис

## `fork(2)`

		#include <unistd.h>

		pid_t fork(void);


## `wait(2)`

       #include <sys/wait.h>

       pid_t wait(int* status);


## `waitpid(2)`

       #include <sys/wait.h>

       pid_t waitpid(pid_t pid, int* status, int options);


## `exit(3)`

		#include <stdlib.h>

        void exit(int status);


# Семантика

## `fork(2)`

Функцията `fork` създава нов процес чрез копиране на вече съществуващия такъв.    Новият процес се нарича процес-дете, а старият - процес-родител.
При `fork` се копира всичко от паметта, свързана с процеса: изображението му (т.е. програмата, която се изпълнява), стекът с извикванията, хийпът на процеса, както и файловите дескриптори и текущия контекст на процеса.  Родителят и детето са напълно независими един от друг и сегментите им в паметта са напълно отделни.
`fork` връща процесния идентификатор (*PID*) на новосъздадения процес и не приема аргументи.  При провал на операцията върнатата стойност е `-1`.


## `wait(2)`

Функцията `wait` изчаква приключването на който и да е процес от децата на текущия процес, т.е. тя блокира изпълнението на програмата, докато той не завърши.  В аргумента `status` се подава указател към целочислена променлива, в която се запазва върнатият изходен код от процеса-дете (който всъщност е аргументът, подаден на `exit` в процеса-дете, или върнатата стойност в неговата `main` функция), както и друга информация, свързана с приключването на процеса.  `status` не може да бъде `NULL`, дори да не се ползва от процеса-родител впоследствие.


## `waitpid(2)`

Функцията `waitpid` изчаква приключването процеса с посочения в аргумента `pid` процесен идентификатор.  Той трябва да е дете на текущия процес.  Аргументът `status` се ползва по същия начин, както в `wait`, а в `options` се подават специални флагове (по подразбиране се подава стойност `0`).


## `exit(3)`

Функцията `exit` се използва за приключване на изпълнението на процес с подадения в аргумента `status` изходен код (който се използва от `wait` и `waitpid`, вж. горе).  Вътрешно тя извиква системния примитив `_exit(2)`.


# Задачи

1. Да се напише програма `catwc`, която изпълнява `cat` и след това `wc -c` върху всеки от файловете, подадени като командни аргументи.  `cat` трябва да се изпълни преди `wc`, а редът, в който са посочени файловете, няма значение:

		$ catwc FILE...

2. Да се напише програма `trf`, която изпълнява командата `tr SET1 SET2`  върху всеки от файловете, подадени като командни аргументи.  Редът, в който са посочени файловете, няма значение:

		$ trf SET1 SET2 FILE...

3.  Да се напишат по конкурентен начин следните програми, като `gennum` трябва да използва `helper`, за да създава отделните файлове, а `sumnum` да използва файловете, генерирани от `gen`:

        $ gennum N M
        $ sumnum N M
        $ helper FILENO START LENGTH

`gennum` създава файловете `1`, `2`, ..., `N`, които съдържат следните числа, посочени вдясно от двоеточията, в бинарен формат:

        1: 1 2 3 ... M
        2: M+1 M+2 ... 2M
        ...
        N: (N-1)M+1 (N-1)M+2 ... NM

`sumnum` създава файловете `1.sum`, `2.sum`, ..., `N.sum`, които съдържат следните числа, посочени вдясно от двоеточията (получени след извършването на съответните сумирания), в бинарен формат:

        1.sum: 1+2+3+...+M
        2.sum: (M+1)+(M+2)+...+2M
        ...
        N.sum: ((N-1)M+1)+((N-1)M+2)+...+NM

`helper` генерира всеки отделен файл `1`, `2`, `3`, ..., `N`.  Той трябва да се позлва от `gennum`.

Накрая да се изведе общата сума от сумите на стандартния изход (това може да се случи в друга програма).