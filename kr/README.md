1. Напишете програма, която приема число *N* и пътищата към два файла като аргументи и добавя към първия файл съдържанието на втория файл *N* символа след края на първия.
    *Забележка:* Не трябва да се използва `write`, за да се изведат самите символи от празното пространство между двата файла.

2. Напишете програма `trf`, която се извиква по следния начин: `trf SET1 SET2 FILE DEST`.  Тя трябва да изпълни командата `tr SET1 SET2` по такъв начин, че `tr` да чете от файла `FILE` и да пише във файла `DEST`.

3. Да се напише програма `trf`, която изпълнява командата `tr SET1 SET2` върху всеки един от файловете, подадени като командни аргументи, и извежда резултата на стандартния изход.  Да се реализира по такъв начин, че файловете да се обработват конкурентно (т.е. независимо един от друг).  Редът, в който са посочени като параметри файловете, няма значение:

        $ trf SET1 SET2 FILE...

4. Да се реализират следните команди чрез канали между съответните процеси (`argv[i]` е *i*-тият команден аргумент, а `argv[i..]` са всички командни аргументи от *i* натам):

   * `grep argv[1..] | sort | uniq | wc -l`
   * `argv[1] argv[2] | argv[3] argv[4] | ... argv[N-1] argv[N]`


**Бонус**. Да се напише програма, която убива всички процеси с идентификатори, подадени като командни аргументи.

**Бонус 2**. Да се напише програма, която убива всички процеси с име на изпълнимия файл, подадено като команден аргумент.

**Бонус 3**. Да се напише команден интерпретатор.  Това е програма, която извежда `$ ` на стандартния изход, чете комаден ред (списък от командни параметри, разделени с интервали), и го изпълнява.
След това започва тя започва отначало, докато не бъде въведена една от думите `exit` или `quit`.
Ако някоя от въведените команди не съществува, да се изведе подходящо съобщение за грешка, без да се приключва изпълнението на интерпретатора.